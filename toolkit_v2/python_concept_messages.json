{
	"Naming Conventions": "The naming of variables are judged under two categories, legal vs. illegal and idiomatic vs. non-idiomatic. Legal conventions are based on how the compiler reads the variable. If the compiler can read the name without issue the name is legal, however if the name violates these conventions (such as using a reserved word or starting with a didgit) the computer will judge it as illegal and will usually throw an error. Idiomatic conventions pertain to how humans read the variable name. Idiomatic names are considered best practice to preserve readability for humans, and while non-idiomatic names will not cause errors, they are highly discauraged as they will cause confusion for humans down the road. Examples of idiomatic naming conventions include using snake_case to name variables and using SCREAMING_SNAKE_CASE for constants.",
	"Type Coercions": "Type Coercion is changing a variable from one data type to another. This is done explicitly by using built in function like int() and str(). For example the string ‘1’ can be changed into an int with int(’1’). Implicit coercion is when data types are changed without the specific use of coercion to a specific data type. This is done either through use of functions like print() which will change any object put into it into a string, or when mixing certain data types (ex. adding a float and an int will cover the int to a float before adding their values)",
	"Definitions and Calls": "In order to create a new function you must 'define' or 'declare' it with a unique name using the following convention: 'def function_name():'. Once the function is defined it cannot be used until it is 'called' (also refered to as invoking, executing, or running the function), and can be called any number of times. Calling the function executes the code block contained in the function.",
	"Return Values": "All functions return a value when called, however by default it will return None if not specified. The 'return' statement is used to return a specific value from the function, allowing the function to perform operaions from one or more inputs and send back a result. 'Predicates' are a unique type of return value refering to a boolean True or False value.",
	"Parameters vs. Arguements": "Arguments are objects passed to a function during invocation. Parameters are placeholders for the objects that will be passed to the function when it is invoked. The difference is that an arguement is an exact value or object being passed from outside the function into it during the call, while a parameter is a local variable exclusive to the code block within the function that is defined to point to whatever the arguement that is passed in is",
	"Scope": "Scope determines where identifiers can be used based on where they are initialized. In Python, functions have their own self contained scope wherein any identifiers declared within the function are only accessable within that function unless specifically defined as global variables. Note that mutations made to mutable objects within a lower scope will apply globally (See 'Mutability' for more information).",
	"Nested Functions": "Relating to scope, just as global variables and objects can be accessed within a funtion, so too can functions defined at a higher level of scope be executed within another function.",
    "Output vs. Return Values": "Output refers to whatever is displayed to the user when running the function, such as any print() function. While a function can have any number of outputs, it can only return one value, which does not necessarily have to be seen by the user.",
    "Side Effects": "",
	"Variable Shadowing": "Relating to scope, variable shadowing is when a variable declared at a higher level is reassigned in a lower level using the same name. The result is that while the lower scope will recognize the redefined value of the variable, the variable will continue to point to its original definition at the scope of its original initialization.",
	"ValueError": "When a function receives and argument that is the correct type but the wrong value. For example, a function trying to find the square root of a number will throw a ValueError if it receives a negative number.",
    "ZeroDivisionError": "Occurs when division by zero is attempted. Because it is not mathematically possible, the compiler will not even attempt it and throw an error instead.",
	"Operators": "",
	"f-strings": "Short for ‘formatted string literals’, f-strings are strings that allow interpolation, which allows other Python expressions to be inserted into the string when enclosed in braces. Ex: f’See inserted expression: {expression}’",
	"Truthiness": "Describes how Python evaluates non-Boolean values in a Boolean context, usually in the context of a conditional statement. Truthiness is not the same as a True or False value, as truthy and falsy are not object values but rather how an object is evaluated by a conditional.",
	"Ranges": "Ranges are a type of non-mutable sequences (meaning they are ordered collections). Ranges are homogenous, meaning they can only contain a single data type (integers), unlike heterogenous sequences (lists and tuples) that can hold multiple different object types.",
	"Mutability": "Mutability is the ability of an object to be mutated, which is having changes made to the object itself in memory. An example of this would to change objects within a list (a type of mutable sequence). When an object is mutated, all references to the object reflect that change. For example, say variable_1 and variable_2 both refer to the list object [1, 2, 3]. If variable_1 reassigns index 0 to become 2 is mutates the collection. As a result both variable_1 and variable_2 will be [2, 2, 3]. Note that because the changes are made to the object in memory, the changes are not constrained by variable scope, so that any mutation done by a local variable will apply to any global variables pointing to the same object.",
	"Expressions": "An expression is something that has a value and must be evaluated to determine that value. They can be literals, variable references, the result of arithmetic, comparison, or concatenation, or the return value of a function as long as the evaluate to a single value or object. Note that creating a variable is not an expression, as it is an act of assignment not evaluation. X = 5 is not an expression, though the integer 5 by itself is.",
	"Statements": "A statement is an instruction to perform an action that does not return a value. Examples include assigning a value to a variable, flow control (if, else, while, for), functions using def or class, import statements, or return statements (note that the ‘return’ keyword does not actually evaluate to a value, it performs the action of returning a value, which makes it a statement and not an expression.",
	"Shallow vs. Deep Copies": "",
	"Intialization and Assignment": "A variable is initialized (created) by naming it then assigning is to a value with the equal sign. Assignment is needed to create a variable, assignment is when the name of the variable is pointed to value (can be any object) stored in memory. Reassignment is when a variable previously initiated and assigned to a value is assigned a new value, replacing the old one. Note that the original object in memory that the variable pointed to was not changed, the variable now points to a new and separate object.",
    "Variables As Pointers": "While variables are referred to as storing a value, they do not actually store any data themselves functionally. Instead they point to the location in memory where the data is actually stored. Thus, if you change the object a variable points to the previous object still exists at the same location in memory and can still be assigned to the same or a different variable.",
    "Variable Shadowing": "Relating to scope, variable shadowing refers to when a global variable is reassigned locally. Within the local scope the reassignment of the variable will apply, however if the variable is referenced at the global level it will have its original value.",
    "if": "An 'if' statement is a conditional statement that evaluates a given combination of comparison and logical operators and branches based on if the result is True or False. Multiple conditions can be compared in an 'if' statement with the 'else' and 'elif' keywords.",
    "while": "",
    "for": ""
}