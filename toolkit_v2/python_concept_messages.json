{
	"Naming Conventions": "The naming of variables are judged under two categories, legal vs. illegal and idiomatic vs. non-idiomatic. Legal conventions are based on how the compiler reads the variable. If the compiler can read the name without issue the name is legal, however if the name violates these conventions (such as using a reserved word or starting with a didgit) the computer will judge it as illegal and will usually throw an error. Idiomatic conventions pertain to how humans read the variable name. Idiomatic names are considered best practice to preserve readability for humans, and while non-idiomatic names will not cause errors, they are highly discauraged as they will cause confusion for humans down the road. Examples of idiomatic naming conventions include using snake_case to name variables and using SCREAMING_SNAKE_CASE for constants.",
	"Type Coercions": "",
	"Definitions and calls": "In order to create a new function you must 'define' or 'declare' it with a unique name using the following convention: 'def function_name():'. Once the function is defined it cannot be used until it is 'called' (also refered to as invoking, executing, or running the function), and can be called any number of times. Calling the function executes the code block contained in the function.",
	"Return Values": "All functions return a value when called, however by default it will return None if not specified. The 'return' statement is used to return a specific value from the function, allowing the function to perform operaions from one or more inputs and send back a result. 'Predicates' are a unique type of return value refering to a boolean True or False value.",
	"Parameters vs. Arguements": "Arguments are objects passed to a function during invocation. Parameters are placeholders for the objects that will be passed to the function when it is invoked. The difference is that an arguement is an exact value or object being passed from outside the function into it during the call, while a parameter is a local variable exclusive to the code block within the function that is defined to point to whatever the arguement that is passed in is",
	"Scope": "Scope determines where identifiers can be used based on where they are initialized. In Python, functions have their own self contained scope wherein any identifiers declared within the function are only accessable within that function unless specifically defined as global variables. Note that mutations made to mutable objects within a lower scope will apply globally (See 'Mutability' for more information).",
	"Nested Functions": "Relating to scope, just as global variables and objects can be accessed within a funtion, so too can functions defined at a higher level of scope be executed within another function.",
    "Output vs. Return Values": "Output refers to whatever is displayed to the user when running the function, such as any print() function. While a function can have any number of outputs, it can only return one value, which does not necessarily have to be seen by the user.",
    "Side Effects": "",
	"Variable Shadowing": "Relating to scope, variable shadowing is when a variable declared at a higher level is reassigned in a lower level using the same name. The result is that while the lower scope will recognize the redefined value of the variable, the variable will continue to point to its original definition at the scope of its original initialization.",
	"Exceptions": "",
	"Operators": "",
	"f-strings": "",
	"String Methods": "",
	"Truthiness": "",
	"Ranges": "",
	"List Methods": "",
	"Mutability": "",
	"Expressions vs. Statements": "",
	"Shallow vs. Deep Copies": "",
	"Intialization and Assignment": "",
    "Variables As Pointers": "",
    "Variable Shadowing": "",
    "if": "An 'if' statement is a conditional statement that evaluates a given combination of comparison and logical operators and branches based on if the result is True or False. Multiple conditions can be compared in an 'if' statement with the 'else' and 'elif' keywords.",
    "while": "",
    "for": ""
}